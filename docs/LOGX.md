# LOGX - Log eXtended

A variation of my in-house **Logy** logger which, like this, is an extension of
the basic built-in logger. I am not a fan of bringing JSON or XML to logs, so I
prefer the elegance of a basic logger.

Unlike **Loggy** this **LogX** version does not (yet) support logging levels 
(DEBUG,INFO,WARN,ERROR,FATAL) but it does support filtering and a per-app
logger configuration file. It makes for clean logs that are easily integrated,
with backwards compatibility (mostly).

> go build -tags logx PATH

Features:

* *Logx* instrumentation available with the `-tags logx` build tag. Else
  they are replace with empty functions or the GO built-in `log` package.
* Pretty-printed logs where signs say more than words.
* You can selectively filter out your own GO packages by not white-listing
  them in the `.logfilter` file.
* Log output of White-listed packages can be further fine-grained by
  specifying specific GO objects (structs) that are allowed to log.
* Extended functionality like `Enter(), Leave(), EventEnter(), EventLeave(),
  Ctor()` and `Step()`.
* The extended logger automatically fills in package/object/function/method
  info.
* Separate (and optional) call tree support. Especially useful for checking
  functional spec compliance in GUI applications.

Here is a sample log produced with LOGX by the photoQ application:

```
2025/08/06 18:31:42 >>>>>> Welcome to photoQ <<<<<<
2025/08/06 18:31:42 âŸ« (Ctor) main:newFileUI()
2025/08/06 18:31:42 âŸ« (Ctor) main:newLedsUI()
2025/08/06 18:31:42 âŸ« (Ctor) main:newPrefixUI()
2025/08/06 18:31:42 âŸ« (Ctor) main:newDateTimeUI()
2025/08/06 18:31:42 âŸ« (Ctor) main:newTaxonomyUI()
2025/08/06 18:31:42 ðŸ‘£ TaxonomyGadget acquired singlClassifier Singleton
2025/08/06 18:31:42 âŸ« (Ctor) main:newQApplyUI()
2025/08/06 18:31:42 â¯ main:buildFileMenu()
2025/08/06 18:31:42 â® main:buildFileMenu()
2025/08/06 18:31:42 â¯ main:TaxonomyGadget.Define()
2025/08/06 18:31:42 â¯ main:TaxonomyGadget.initializeTaxonomyDB()
2025/08/06 18:31:42 â¯ dataQ:PreLoadDefaultPictureClassification()
2025/08/06 18:31:42 ðŸ‘£ Sources with 7 items
2025/08/06 18:31:42 ðŸ‘£ Modifier with 6 items
2025/08/06 18:31:42 ðŸ‘£ Extra with 4 items
2025/08/06 18:31:42 ðŸ‘£ Category with 11 items
2025/08/06 18:31:42 ðŸ‘£ Subcategory with 11 items
2025/08/06 18:31:42 ðŸ‘£ Variant with 6 items
2025/08/06 18:31:42 â® dataQ:PreLoadDefaultPictureClassification()
2025/08/06 18:31:42 â® main:TaxonomyGadget.initializeTaxonomyDB()
2025/08/06 18:31:42 â® main:TaxonomyGadget.Define()
2025/08/06 18:31:42 â¯ main:TaxonomyGadget.Refine()
2025/08/06 18:31:43 â® (Event) dataq:Classifier.onSchemaLoaded()
2025/08/06 18:31:43 â¯ (Event) dataq:Classifier.onSchemaLoaded()
```

As you can see, it is easy to identify visits to a constructor, entry/departure
from a function or method or just plain steps. Best of all, the programmer
is spared from creating `log` statements with hard-coded function/method names.
Why? beause `logx` automatically fills that information. It is as easy as:

```
function (m *MultiTasker) OnNewTask() {
    logx.EnterEvent()
       :
    logx.LeaveEvent()
}
```

Better yet, you can convert your old `log.Print*()` to `logx.Print*()`. 
Too much logged information? you can specify which of your application
packages (those instrumented with `logx`) are white-listed. Great for
situations where you are debugging a part of the application and do not
need all the other logging information. For that you name your GO 
fully-qualified package name in the application's `.logfilter` file.

Furthermore, you can even fine-grain the white-listed packages by 
narrowing down which objects (Go `structs`) would actually generate
log output, the others in the same package are then silenced.

And all of the `logx` instrumentation can be removed by building 
without the `logx` *build tag*.

### The Log Filter

The log filter file has the name of the application with the filter
extension: `photoQ.logfilter` and in Linux it is located in the
user's configuration directory `${HOME}/.config/coralys/` directory.

A sample config file can be generated by having your program call
the `logx` Singleton's `SaveFilter()` method. It should be automatically
loaded during startup.

```
{
  "appname": "photoQ",
  "level": "debug",
  "filters": {
    "lordofscripts/photoQ/internal/dataQ": {
      "log_level": "info",
      "specifically": "StructA,StructB"
    },
    "main": {
      "log_level": "debug",
      "specifically": "TaxonomyGadget,QApplyGadget"
    },
    "lordofscripts/photoQ": {
      "log_level": "warn",
      "specifically": "*"
    }    
  }
}
```

### The Call Tree

I am developing this Fyne GUI application and I needed to see a cause-effect
log, free of other logged data, of when a Widget's (or application) callback
was being invoked and when -as a result of that- modified values were being
propagated to other widgets. And, I wanted to see the call-tree depth (nesting level)
as well.

I added a few non-conditional LOGX functions for that purpose. First, in your
application, after you got the LogX instance, you must call this method to tell
LogX to which separate file (separate from your application log file if any) you
want the live call tree outputted. You can view it with `tail -F`. For that you
set LogX this way:

```go
    logx.SingLogGate = logx.GetLogGateInstance(APPNAME, APPGROUP_SUBDIR)
    logx.SingLogGate.WithConfigSubdirectory(APPGROUP).SetAppName(APPNAME).LoadFilters()
    logx.SingLogGate.WithCallTree(CALL_TREE_FILE)
```

Then on a Bash shell (or your favorite GUI Log viewer) you could follow it with:

```
    tail -f /tmp/call_tree.log
```

You also need to instrument your application with the appropriate extra-functionality
calls:

`logx.OnValidating()` should be used as the first instruction in any callback that
represents a validation step, for example `fyne.validation` callbacks.

`log.OnChanged()` should be used as the first instruction on any callback that is
used for Fyne widget's `OnChange` event handling.

`logx.OnCascade(to string, val any)` should be used within a function or method that
sets a widget's display value. This is typically a call do `entry.SetText` or
`checkbox.SetChecked` or `select.SetSelected`. It helps auditing cause-effect while
looking at the **Call Tree Log**.

`logx.OnClick()` should be used in any function or method that is a callback in response
to a widget's click event, primarily `button.OnClick`.

These supplementary API calls are special because:

* They are not conditional, they log regardless of the filters.
* They automatically calculate the current nesting level and the calling function/method's
  package, struct and function/method name. It is done for you.